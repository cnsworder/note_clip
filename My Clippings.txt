一个“蝇量级” C 语言协程库 (Leo)
- 您在位置 #95-95的标注 | 添加于 2014年10月16日星期四 上午8:50:57

编程规范的目标就是为了代码清晰。
==========
﻿一个“蝇量级” C 语言协程库 (Leo)
- 您在位置 #97-98的标注 | 添加于 2014年10月16日星期四 上午8:51:11

任何编程规范，坚持牺牲算法清晰度来换取语法清晰度的，都应该重写。
==========
﻿一个“蝇量级” C 语言协程库 (Leo)
- 您在位置 #106-107的标注 | 添加于 2014年10月16日星期四 上午8:53:16

既然协程本身是一种单线程的方案，那么我们应该假定应用环境是单线程的，不存在代码重入问题
==========
﻿『暗时间』读书笔记 - 博客 - 伯乐在线  
- 您在位置 #12-13的标注 | 添加于 2014年10月17日星期五 下午4:09:04

人与人学习的差距不在资质上，而在花在思考的时间和思考的深度上。
==========
﻿『暗时间』读书笔记 - 博客 - 伯乐在线  
- 您在位置 #100-101的标注 | 添加于 2014年10月17日星期五 下午4:40:25

GitHub+书单，你最好的简历
==========
﻿『暗时间』读书笔记 - 博客 - 伯乐在线  
- 您在位置 #43-43的标注 | 添加于 2014年10月17日星期五 下午4:41:31

主题学习
==========
﻿『暗时间』读书笔记 - 博客 - 伯乐在线  
- 您在位置 #53-53的标注 | 添加于 2014年10月17日星期五 下午4:41:36

讲清楚思维过程
==========
﻿『暗时间』读书笔记 - 博客 - 伯乐在线  
- 您在位置 #71-71的标注 | 添加于 2014年10月17日星期五 下午4:42:06

书写是为了更好的思考
==========
﻿『暗时间』读书笔记 - 博客 - 伯乐在线  
- 您在位置 #86-86的标注 | 添加于 2014年10月17日星期五 下午4:43:16

用自己的话复述一遍之后理解得更深刻（
==========
﻿『暗时间』读书笔记 - 博客 - 伯乐在线  
- 您在位置 #117-118的标注 | 添加于 2014年10月17日星期五 下午4:44:46

规划：分割你的任务
==========
﻿『暗时间』读书笔记 - 博客 - 伯乐在线  
- 您在位置 #126-126的标注 | 添加于 2014年10月17日星期五 下午4:45:56

，能够从纷繁的信息中抽象出问题，
==========
﻿C语言点滴 (赵岩)
- 您在位置 #473-473的标注 | 添加于 2014年10月17日星期五 下午5:11:54

http://www.hrbxinzhi.com/internet/resource2.html 上的“Google 搜索从入门到精通”，
==========
﻿C语言点滴 (赵岩)
- 您在位置 #594-595的标注 | 添加于 2014年10月17日星期五 下午5:27:49

http://www.weibo.com/zhaoyanhrb，
==========
﻿C语言点滴 (赵岩)
- 您在位置 #4238-4238的标注 | 添加于 2014年10月18日星期六 下午1:44:42

Windows 程序调试
==========
﻿C语言点滴 (赵岩)
- 您在位置 #4282-4282的标注 | 添加于 2014年10月18日星期六 下午4:37:04

如果上帝关上了门，同时也关上了窗户，那就是他老人家想见你了。
==========
﻿C语言点滴 (赵岩)
- 您在位置 #4414-4419的标注 | 添加于 2014年10月18日星期六 下午4:55:08

• 蒙汗药——断点； • 时间机器——单步执行； • 手术刀——监视窗； • 显微镜——内存影响； • 病例——函数调用栈； • 防火墙——assert； • 板砖——fprintf。
==========
﻿C语言点滴 (赵岩)
- 您在位置 #4450-4452的标注 | 添加于 2014年10月18日星期六 下午5:01:00

“bug”三个字母，看到需要三秒，找到需要三小时，debug 却要一辈子。正所谓，为系统而生，为框架而死，为debug 奋斗一辈子！吃符号的亏，上大小写的当，最后死在需求上。这，也许就是一个程序员的宿命吧！
==========
﻿C语言点滴 (赵岩)
- 您在位置 #4488-4489的标注 | 添加于 2014年10月18日星期六 下午5:07:56

因为任何库函数在使用前都不会主动地将errno 设为0，
==========
﻿C语言点滴 (赵岩)
- 您在位置 #4590-4591的标注 | 添加于 2014年10月18日星期六 下午5:17:09

参考“C++异常机制的实现方式和开销分析”
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #457-457的标注 | 添加于 2014年10月18日星期六 下午8:03:23


==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #458-458的标注 | 添加于 2014年10月18日星期六 下午8:03:30


==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #487 的书签 | 添加于 2014年10月18日星期六 下午8:29:16


==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #753-754的标注 | 添加于 2014年10月18日星期六 下午9:30:31

C++11标准的编译器会将窄字符串转换成宽字符串，然后再与宽字符串进行连接。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #905-906的标注 | 添加于 2014年10月18日星期六 下午9:48:12

我们可以利用“除0”会导致编译器报错这个特性来实现静态断言。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #938-938的标注 | 添加于 2014年10月18日星期六 下午9:50:06

static_assert的断言表达式的结果必须是在编译时期可以计算的表达式，即必须是常量表达式。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #953-954的标注 | 添加于 2014年10月18日星期六 下午9:52:25

异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（unwind），并依帧调用在本帧中已构造的自动变量的析构函数等。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #944 的笔记 | 添加于 2014年10月18日星期六 下午9:56:17

代替废弃的nothrow()
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #944-944的标注 | 添加于 2014年10月18日星期六 下午9:56:17

noexcept修饰符与noexcept操作符
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #944 的笔记 | 添加于 2014年10月18日星期六 下午9:59:47

代替废弃的throw()
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #955-955的标注 | 添加于 2014年10月18日星期六 下午10:01:23

noexcept修饰符有两种形式，一种就是简单地在函数声明后加上noexcept关键字。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1148-1149的标注 | 添加于 2014年10月19日星期日 上午9:32:11

在C++11中，声明一个类为另外一个类的友元时，不再需要使用class关键字。
==========
﻿知乎周刊·无力拖延 (知乎)
- 您在位置 #49-50的标注 | 添加于 2014年10月19日星期日 下午2:22:36

加拿大的斯蒂尔教授曾提出「拖延公式」，提炼了跟拖延最有关系的四个因素：信心不足、意义缺失、冲动分心和回报遥远；
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1303-1305的标注 | 添加于 2014年10月19日星期日 下午2:57:29

❑函数名拼写错，Dijkstra误写作了Dikjstra。 ❑函数原型不匹配，VNeumann函数的参数类型误做了double类型，而DKnuth的常量性在派生类中被取消了。 ❑重写了非虚函数Print。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1328-1330的标注 | 添加于 2014年10月19日星期日 下午3:02:40

函数模板在C++98中与类模板一起被引入，不过在模板类声明的时候，标准允许其有默认模板参数。默认的模板参数的作用好比函数的默认形参。然而由于种种原因，C++98标准却不支持函数模板的默认模板参数。不过在C++11中，这一限制已经被解除了，
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1337-1339的标注 | 添加于 2014年10月19日星期日 下午3:04:05

与类模板有些不同的是，在为多个默认模板参数声明指定默认值的时候，程序员必须遵照“从右往左”的规则进行指定。而这个条件对函数模板来说并不是必须的，
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1398-1405的标注 | 添加于 2014年10月19日星期日 下午3:17:16

外部模板的使用实际依赖于C++98中一个已有的特性，即显式实例化（Explicit Instantiation）。显式实例化的语法很简单，比如对于以下模板： template＜typename T＞void fun(T){} 我们只需要声明： template void fun＜int＞(int); 这就可以使编译器在本编译单元中实例化出一个fun＜int＞(int)版本的函数（这种做法也被称为强制实例化）。而在C++11标准中，又加入了外部模板（Extern Template）的声明。语法上，外部模板的声明跟显式的实例化差不多，只是多了一个关键字extern。对于上面的例子，我们可以通过： extern template void fun＜int＞(int); 这样的语法完成一个外部模板的声明。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1417-1420的标注 | 添加于 2014年10月19日星期日 下午3:19:50

问题：如果外部模板声明出现于某个编译单元中，那么与之对应的显示实例化必须出现于另一个编译单元中或者同一个编译单元的后续代码中；外部模板声明不能用于一个静态函数（即文件域函数），但可以用于类静态成员函数（这一点是显而易见的，因为静态函数没有外部链接属性，不可能在本编译单元之外出现）。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1482 的笔记 | 添加于 2014年10月20日星期一 上午6:48:51

试验确认一下
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1480-1482的标注 | 添加于 2014年10月20日星期一 上午6:48:51

类具有可派生性，派生类可以自动获得基类的成员变量和接口（虚函数和纯虚函数，这里我们指的都是public派生）。不过基类的非虚函数则无法再被派生类使用了。这条规则对于类中最为特别的构造函数也不例外，
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1507-1508的标注 | 添加于 2014年10月20日星期一 上午6:52:57

如果派生类要使用基类的成员函数的话，可以通过using声明（using-declaration）来完成。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1572-1573的标注 | 添加于 2014年10月20日星期一 上午7:04:02

基类的构造函数被声明为私有成员函数，或者派生类是从基类中虚继承的，那么就不能够在派生类中声明继承构造函数。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1632-1632的标注 | 添加于 2014年10月20日星期一 上午7:14:44

委派构造函数不能有初始化列表
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1695-1704的标注 | 添加于 2014年10月20日星期一 上午7:27:10

class DCExcept{ public: DCExcept(double d) try:DCExcept(1,d){ cout＜＜"Run the body."＜＜endl; //其他初始化 } catch(...){ cout＜＜"caught exception."＜＜endl; } private: DCExcept(int i,double d){ cout＜＜"going to throw!"＜＜endl; throw 0; } int type; double data; };
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1873-1874的标注 | 添加于 2014年10月20日星期一 上午8:15:51

可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1875-1876的标注 | 添加于 2014年10月20日星期一 上午8:16:38

C++11中，右值是由两个概念构成的，一个是将亡值（xvalue，eXpiring Value），另一个则是纯右值（prvalue，Pure Rvalue）。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1882-1883的标注 | 添加于 2014年10月20日星期一 上午8:39:48

在C++11的程序中，所有的值必属于左值、将亡值、纯右值三者之一。
==========
﻿Linux线程编程之生产者消费者问题 - clover_toeic - 博客园  
- 您在位置 #23-23的标注 | 添加于 2014年10月20日星期一 下午12:22:12

%为取模运算符，循环队列利用数学上的取模运算将首尾巧妙相连。
==========
﻿并发编程网 (hugozhu)
- 您在位置 #26-28的标注 | 添加于 2014年10月20日星期一 下午12:57:29

内存屏障提供了两个功能。首先，它们通过确保从另一个CPU来看屏障的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；其次它们可以实现内存数据可见性，确保内存数据会同步到CPU缓存子系统。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1904-1905的标注 | 添加于 2014年10月20日星期一 下午1:12:26

常量左值引用在C++98标准中开始就是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1967 的书签 | 添加于 2014年10月20日星期一 下午3:01:40


==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #1967 的书签 | 添加于 2014年10月20日星期一 下午6:48:17


==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #2042-2043的标注 | 添加于 2014年10月20日星期一 下午7:10:47

拷贝构造/赋值和移动构造/赋值函数必须同时提供，或者同时不提供，
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #2124-2124的标注 | 添加于 2014年10月20日星期一 下午7:39:34


==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #2382-2382的标注 | 添加于 2014年10月20日星期一 下午8:35:49

C++11中，列表初始化是唯一一种可以防止类型收窄的初始化方式。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #2394 的笔记 | 添加于 2014年10月20日星期一 下午9:54:23

使用默然构造,析构,拷贝,移动,赋值函数;没有虚函数虚继承
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #2393-2394的标注 | 添加于 2014年10月20日星期一 下午9:54:23

平凡的（trivial）和标准布局的（standard layout）。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #2457-2457的标注 | 添加于 2014年10月20日星期一 下午10:06:02

非静态成员只要同时出现在派生类和基类间，其即不属于标准布局的。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #2458-2459的标注 | 添加于 2014年10月20日星期一 下午10:06:13

类中第一个非静态成员的类型与其基类不同。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #2778-2779的标注 | 添加于 2014年10月20日星期一 下午10:21:49

内联的名字空间允许程序员在父名字空间定义或特化子名字空间的模板。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #2865-2866的标注 | 添加于 2014年10月20日星期一 下午10:30:26

在C++模板中，有一条著名的规则，即SFINEA-Substitution failure is not an error，中文直译即是“匹配失败不是错误”。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #6477-6478的标注 | 添加于 2014年10月20日星期一 下午10:42:07

C++11加入了一个新的顶级namespace：posix。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #3009-3009的标注 | 添加于 2014年10月21日星期二 上午8:35:36

auto声明的变量必须被初始化，以使编译器能够从其初始化表达式中推导出其类型。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #3111-3113的标注 | 添加于 2014年10月21日星期二 下午12:57:45

volatile和const代表了变量的两种不同的属性：易失的和常量的。在C++标准中，它们常常被一起叫作cv限制符（cv-qualifier）。鉴于cv限制符的特殊性，C++11标准规定auto可以与cv限制符一起使用，不过声明为auto的变量并不能从其初始化表达式中“带走”cv限制符。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #3122-3123的标注 | 添加于 2014年10月21日星期二 下午12:58:55

声明为引用的变量e、g都保持了其引用的对象相同的属性（事实上，指针也是一样的）。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #3158-3159的标注 | 添加于 2014年10月21日星期二 下午1:03:22

1）对于函数fun来说，auto不能是其形参类型。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #3160-3161的标注 | 添加于 2014年10月21日星期二 下午1:03:32

2）对于结构体来说，非静态成员变量的类型不能是auto的。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #3163-3163的标注 | 添加于 2014年10月21日星期二 下午1:03:48

3）声明auto数组。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #3164-3164的标注 | 添加于 2014年10月21日星期二 下午1:03:56

4）在实例化模板的时候使用auto作为模板参数，
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #3226-3227的标注 | 添加于 2014年10月21日星期二 下午7:39:24

这里size_t以及ptrdiff_t还有nullptr_t（参见7.1节）都是由decltype推导出的类型。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #3331-3333的标注 | 添加于 2014年10月21日星期二 下午8:08:41

所有除去关键字、字面量等编译器需要使用的标记之外的程序员自定义的标记（token）都可以是标记符（identifier）。而单个标记符对应的表达式就是标记符表达式。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #3327-3330的标注 | 添加于 2014年10月21日星期二 下午8:23:55

1）如果e是一个没有带括号的标记符表达式（id-expression）或者类成员访问表达式，那么decltype(e)就是e所命名的实体的类型。此外，如果e是一个被重载的函数，则会导致编译时错误。 2）否则，假设e的类型是T，如果e是一个将亡值(xvalue)，那么decltype(e)为T＆＆。 3）否则，假设e的类型是T，如果e是一个左值，则decltype(e)为T＆。 4）否则，假设e的类型是T，则decltype(e)为T。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #3630-3632的标注 | 添加于 2014年10月22日星期三 上午8:43:49

枚举还有一个被称为“enum hack”的独特应用，在上面的静态常量的例子中，如果static的Male和Female声明在class中，在一些较早的编译器上不能为其就地赋值（赋值需要在class外），因此有人也采用了enum的方式在class中来代替常量声明。这就是“enum hack”。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #3716-3717的标注 | 添加于 2014年10月22日星期三 上午9:14:27

标准规定，C++枚举所基于的“基础类型”是由编译器来具体指定实现的，
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #3739-3740的标注 | 添加于 2014年10月22日星期三 上午11:56:03

可以指定底层类型。强类型枚举默认的底层类型为int,但也可以显式地指定底层类型，具体方法为在枚举名称后面加上“：type”，其中type可以是除wchar_t以外的任何整型。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #3954-3957的标注 | 添加于 2014年10月22日星期三 下午1:10:56

安全派生指针的操作包括： ❑在解引用基础上的引用，比如：＆*p。 ❑定义明确的指针操作，比如：p+1。 ❑定义明确的指针转换，比如：static_cast＜void*＞(p)。 ❑指针和整型之间的reinterpret_case，比如：reinterpret_cast＜intptr_t＞(p)。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #4071-4074的标注 | 添加于 2014年10月22日星期三 下午8:24:07

❑函数体只有单一的return返回语句。 ❑函数必须返回值（不能是void函数）。 ❑在使用前必须已有定义。 ❑return返回语句表达式中不能使用非常量表达式的函数、全局数据，且必须是一个常量表达式。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #4124-4125的标注 | 添加于 2014年10月22日星期三 下午11:01:20

正确地做法是，定义自定义常量构造函数（constent-expression constructor）。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #4334-4335的标注 | 添加于 2014年10月23日星期四 上午7:51:41

在C++11中，标准要求函数参数包必须唯一，且是函数的最后一个参数（模板参数包没有这样的要求）。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #4366-4372的标注 | 添加于 2014年10月23日星期四 上午8:39:36

一个更为有趣的包扩展表达式如下： template＜typename...A＞class T:private B＜A＞...{}; 注意这个包扩展跟下面的类模板声明： template＜typename...A＞class T:private B＜A...＞{}; 在解包后是不同的，对于同样的实例化T＜X,Y＞，前者会解包为： class T＜X,Y＞:private B＜X＞,private B＜Y＞{}; 即多重继承的派生类，而后者则会解包为： class T＜X,Y＞:private B＜X,Y＞{}; 即派生于多参数的模板类的派生类，这点存在着本质的不同。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #4364-4365的标注 | 添加于 2014年10月23日星期四 上午8:39:50

比如声明了Arg为参数包，那么我们可以使用Arg＆＆...这样的包扩展表达式，其解包后等价于Arg1＆＆,...,Argn＆＆（
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #4442 的书签 | 添加于 2014年10月23日星期四 上午9:03:29


==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #5491-5492的标注 | 添加于 2014年10月24日星期五 上午6:59:46

按值方式传递的捕捉列表，其传递的值在lambda函数定义的时候就已经决定了。而按引用传递的捕捉列表变量，其传递的值则等于lambda函数调用时的值。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #5515-5516的标注 | 添加于 2014年10月24日星期五 上午7:02:25

发现，lambda的类型被定义为“闭包”（closure）的类[1]，而每个lambda表达式则会产生一个闭包类型的临时对象（
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #5515-5516的标注 | 添加于 2014年10月24日星期五 上午7:02:54

lambda的类型被定义为“闭包”（closure）的类[1]，而每个lambda表达式则会产生一个闭包类型的临时对象（右值）。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #5878-5879的标注 | 添加于 2014年10月24日星期五 上午7:35:02

C++11在新标准中为了支持对齐，主要引入两个关键字：操作符alignof、对齐描述符（alignment-specifier）alignas。
==========
﻿深入理解C++11 ：C++11 新特性解析与应用 (原创精品系列) (Michael Wong, IBM XL 编译器中国开发团队)
- 您在位置 #5910-5911的标注 | 添加于 2014年10月24日星期五 上午7:38:09

对齐描述符可以作用于各种数据。具体来说，可以修饰变量、类的数据成员等，而位域（bit field）以及用register声明的变量则不可以。
==========
